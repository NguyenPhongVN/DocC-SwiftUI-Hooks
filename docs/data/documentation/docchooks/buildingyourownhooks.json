{"primaryContentSections":[{"kind":"content","content":[{"anchor":"PropertyWrapper","level":2,"type":"heading","text":"PropertyWrapper"},{"anchor":"HState","level":3,"type":"heading","text":"HState"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/DocCHooks\/documentation\/DocCHooks\/HState"},{"type":"text","text":" Like "},{"type":"codeVoice","code":"@State"},{"type":"text","text":" in SwiftUI, but init inside "},{"type":"codeVoice","code":"HookScope"},{"type":"text","text":". See Also "},{"type":"codeVoice","code":"useState"},{"type":"text","text":"."}]}]}]},{"type":"codeListing","syntax":"swift","code":["@propertyWrapper","public struct HState<Node> {","","  internal let _value: Binding<Node>","","  public init(wrappedValue: @escaping () -> Node) {","    _value = useState(wrappedValue())","  }","","  public init(wrappedValue: Node) {","    _value = useState(wrappedValue)","  }","","  public init(wrappedValue: @escaping () -> Binding<Node>) {","    _value = wrappedValue()","  }","","  public init(wrappedValue: Binding<Node>) {","    _value = wrappedValue","  }","","  public var wrappedValue: Node {","    get {","      _value.wrappedValue","    }","    nonmutating set {","      _value.wrappedValue = newValue","    }","  }","}"]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"How to use HState?"}]}]}]},{"type":"codeListing","syntax":"swift","code":["HookScope {","","  @HState var state = 0","  ","  @HState<Int> var otherState = {","    let initialState = computation() \/\/ Int","    return initialState","  }","","}"]},{"anchor":"HRef","level":3,"type":"heading","text":"HRef"},{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/DocCHooks\/documentation\/DocCHooks\/HRef"},{"type":"text","text":" A propertyWrapper for "},{"type":"codeVoice","code":"useRef"},{"type":"text","text":" hook."}]},{"type":"codeListing","syntax":"swift","code":["@propertyWrapper","public struct HRef<Node> {","","  private let _value: RefObject<Node>","","  @SAnyRef","  internal var _ref: ((Node) -> Void)? = nil","","  public init(wrappedValue: @escaping () -> Node) {","    _value = useRef(wrappedValue())","  }","","  public init(wrappedValue: Node) {","    _value = useRef(wrappedValue)","  }","","  public var wrappedValue: Node {","    get {","      _value.current","    }","    nonmutating set {","      _value.current = newValue","      if let value = _ref {","        value(newValue)","      }","    }","  }","","  public var projectedValue: Self {","    self","  }","","  public var value: RefObject<Node> {","    _value","  }","","  public func send(_ node: Node) {","    value.current = node","  }","","  public func onUpdated(_ onUpdate: @escaping (Node) -> Void) -> Self {","    _ref = onUpdate","    return self","  }","}",""]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"How to use HRef?"}]}]}]},{"type":"codeListing","syntax":"swift","code":["HookScope {","  @HRef var state = 0","}"]},{"anchor":"HContext","level":3,"type":"heading","text":"HContext"},{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/DocCHooks\/documentation\/DocCHooks\/HContext"},{"type":"text","text":" A propertyWrapper for "},{"type":"codeVoice","code":"useContext"},{"type":"text","text":" hook."}]},{"type":"codeListing","syntax":"swift","code":["@propertyWrapper","  public struct HContext<Node> {","","  public typealias Context = Hooks.Context<Node>","","  public init(wrappedValue: @escaping () -> Context.Type) {","    self.wrappedValue = wrappedValue()","  }","","  public init(wrappedValue: Context.Type) {","    self.wrappedValue = wrappedValue","  }","","  public var wrappedValue: Context.Type","","  public var projectedValue: Self {","    self","  }","","  public var value: Node {","    useContext(wrappedValue)","  }","}"]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"How to use HContext?"}]}]}]},{"type":"codeListing","syntax":"swift","code":["HookScope {","  @HContext","  var todoContext = TodoContext.self","  let todos = $todoContext.value","}",""]},{"anchor":"HMemo","level":3,"type":"heading","text":"HMemo"},{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/DocCHooks\/documentation\/DocCHooks\/HMemo"},{"type":"text","text":" A propertyWrapper for "},{"type":"codeVoice","code":"useMemo"},{"type":"text","text":" hook."}]},{"type":"codeListing","syntax":"swift","code":["@propertyWrapper","  public struct HMemo<Node> {","","  private let initialNode: () -> Node","","  private let updateStrategy: HookUpdateStrategy","","  public init(","    wrappedValue: Node,","    _ updateStrategy: HookUpdateStrategy = .once","  ) {","    initialNode = { wrappedValue }","    self.updateStrategy = updateStrategy","  }","","  public init(","    wrappedValue: @escaping () -> Node,","    _ updateStrategy: HookUpdateStrategy = .once","  ) {","    initialNode = wrappedValue","    self.updateStrategy = updateStrategy","  }","","  public var wrappedValue: Node {","    useMemo(updateStrategy, initialNode)","  }","","  public var projectedValue: Self {","    self","  }","","  public var value: Node {","    wrappedValue","  }","}"]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"How to use HMemo?"}]}]}]},{"type":"codeListing","syntax":"swift","code":["HookScope {","  @HState var state = 0","","  @HMemo(.preserved(by: state))","  var randomColor = Color(hue: .random(in: 0...1), saturation: 1, brightness: 1)","","}",""]},{"anchor":"HEnvironment","level":3,"type":"heading","text":"HEnvironment"},{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/DocCHooks\/documentation\/DocCHooks\/HEnvironment"},{"type":"text","text":" A propertyWrapper for "},{"type":"codeVoice","code":"useEnvironment"},{"type":"text","text":" hook."}]},{"type":"codeListing","syntax":"swift","code":["@propertyWrapper","  public struct HEnvironment<Value> {","","  public init(_ keyPath: KeyPath<EnvironmentValues, Value>) {","    self.wrappedValue = useEnvironment(keyPath)","  }","","  public var wrappedValue: Value","","  public var projectedValue: Self {","    self","  }","","  public var value: Value {","    wrappedValue","  }","}"]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"How to use HEnvironment?"}]}]}]},{"type":"codeListing","syntax":"swift","code":["HookScope {","  @HEnvironment(\\.dismiss)","  var dismiss","}"]},{"anchor":"Building-from-other-Hook","level":2,"type":"heading","text":"Building from other Hook"},{"anchor":"useValueChanged","level":3,"type":"heading","text":"useValueChanged"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Watches a value and triggers a callback whenever the value changed."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"useValueChanged"},{"type":"text","text":" takes a valueChange callback and calls it whenever value changed. valueChange will not be called on the first useValueChanged call."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"useValueChanged"},{"type":"text","text":" can also be used to interpolate Whenever useValueChanged is called with a different value, calls valueChange. The value returned by useValueChanged is the latest returned value of valueChange or null."}]},{"type":"codeListing","syntax":"swift","code":["@discardableResult","public func useValueChanged<Node: Equatable>(","  _ value: Node,","  callBack: @escaping (Node, Node) -> Void",") -> Node {","  @HRef","  var cache = value","  useLayoutEffect(.preserved(by: value)) {","      if cache != value {","      callBack(cache, value)","      cache = value","    }","    return nil","  }","  return cache","}",""]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"How to use useValueChanged?"}]}]}]},{"type":"codeListing","syntax":"swift","code":["HookScope {","","  @HState","  var state = 0","","  let newValue = useValueChanged(state) { old, new in","    log.info(\"oldValue: \\(old)\")","    log.info(\"newValue: \\(new)\")","  }","","  VStack {","    Stepper(value: $state) {","      Text(newValue.description)","    }","  }","  .padding()","  .font(.largeTitle)","}",""]},{"anchor":"useCount","level":3,"type":"heading","text":"useCount"},{"type":"codeListing","syntax":"swift","code":["public func useCount(","  _ updateStrategy: HookUpdateStrategy = .once",") -> Int {","  @HState var count = 0","  useMemo(updateStrategy) {","    count += 1","  }","  return count","}",""]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"How to use useCount?"}]}]}]},{"type":"codeListing","syntax":"swift","code":["HookScope {","  @HState var count = 0","  let countChanged = useCount(count)","}",""]},{"anchor":"Building-Custom-Hooks","level":2,"type":"heading","text":"Building Custom Hooks."},{"type":"codeListing","syntax":"swift","code":["\/\/ MARK: Call operation only running `refresher` action, It will updateUI result status AsyncPhase.","","\/\/\/ A hook to use the most recent phase of the passed non-throwing asynchronous operation, and a `perform` function to call the it at arbitrary timing.","\/\/\/","\/\/\/     let (phase, refresh) = useAsyncRefresh {","\/\/\/         try! await URLSession.shared.data(from: url)","\/\/\/     }","\/\/\/","\/\/\/ - Parameter operation: A closure that produces a resulting value asynchronously.","\/\/\/ - Returns: A tuple of the most recent async phase and its perform function.","","@discardableResult","public func useAsyncRefresh<Output>(","  _ operation: @escaping @MainActor () async -> Output",") -> (phase: AsyncPhase<Output, Never>, refresher: AsyncCompletion) {","  useHook(AsyncRefreshHook(operation: operation))","}","","\/\/\/ A hook to use the most recent phase of the passed throwing asynchronous operation, and a `perform` function to call the it at arbitrary timing.","\/\/\/","\/\/\/     let (phase, refresh) = useAsyncRefresh {","\/\/\/         try await URLSession.shared.data(from: url)","\/\/\/     }","\/\/\/","\/\/\/ - Parameter operation: A closure that produces a resulting value asynchronously.","\/\/\/ - Returns: A most recent async phase.","@discardableResult","public func useAsyncRefresh<Output>(","_ operation: @escaping @MainActor () async throws -> Output",") -> (phase: AsyncPhase<Output, Error>, refresher: ThrowingAsyncCompletion) {","  useHook(AsyncThrowingRefreshHook(operation: operation))","}","","private struct AsyncRefreshHook<Output>: Hook {","","  typealias State = _HookRef","","  typealias Phase = AsyncPhase<Output, Never>","","  typealias Value = (phase: Phase, refresher: AsyncCompletion)","","  let updateStrategy: HookUpdateStrategy? = .once","","  let operation: @MainActor () async -> Output","","  func makeState() -> State {","    State()","  }","","  func value(coordinator: Coordinator) -> Value {","    let phase = coordinator.state.phase","    let refresher: AsyncCompletion = {","      guard !coordinator.state.isDisposed else {","        return","      }","      coordinator.state.task = Task { @MainActor in","        let output = await operation()","        if !Task.isCancelled && !coordinator.state.isDisposed {","          coordinator.state.phase = .success(output)","          coordinator.updateView()","        }","      }","    }","    return (phase: phase, refresher: refresher)","  }","","  func updateState(coordinator: Coordinator) {","    guard !coordinator.state.isDisposed else {","      return","    }","  }","","  func dispose(state: State) {","    state.dispose()","  }","}","","private extension AsyncRefreshHook {","\/\/ MARK: State","  final class _HookRef {","","    var phase: Phase = .pending","","    var task: Task<Void, Never>? {","      didSet {","        oldValue?.cancel()","      }","    }","","    var isDisposed = false","","    func dispose() {","      task = nil","      isDisposed = true","    }","  }","}","","private struct AsyncThrowingRefreshHook<Output>: Hook {","","  typealias State = _HookRef","","  typealias Phase = AsyncPhase<Output, Error>","","  typealias Value = (phase: Phase, refresher: ThrowingAsyncCompletion)","","  let updateStrategy: HookUpdateStrategy? = .once","","  let operation: @MainActor () async throws -> Output","","  func makeState() -> State {","    State()","  }","","  func value(coordinator: Coordinator) -> Value {","    let phase = coordinator.state.phase","    let refresher: ThrowingAsyncCompletion = {","      guard !coordinator.state.isDisposed else {","        return","      }","      coordinator.state.task = Task { @MainActor in","        guard !coordinator.state.isDisposed else {","          return","        }","        let phase: AsyncPhase<Output, Error>","      do {","          let output = try await operation()","          phase = .success(output)","        } catch {","          phase = .failure(error)","        }","        if !Task.isCancelled && !coordinator.state.isDisposed {","          coordinator.state.phase = phase","          coordinator.updateView()","        }","      }","    }","    return (phase: phase, refresher: refresher)","  }","","  func updateState(coordinator: Coordinator) {","    guard !coordinator.state.isDisposed else {","      return","    }","  }","","  func dispose(state: State) {","    state.isDisposed = true","  }","}","","private extension AsyncThrowingRefreshHook {","\/\/ MARK: State","  final class _HookRef {","","    var phase: Phase = .pending","","    var task: Task<Void, Never>? {","      didSet {","        oldValue?.cancel()","      }","    }","","    var isDisposed = false","","    func dispose() {","      task = nil","      isDisposed = true","    }","  }","}"]},{"anchor":"useSetState","level":3,"type":"heading","text":"useSetState"},{"type":"codeListing","syntax":"swift","code":["\/\/\/ A hook to use a `Binding<Node>` wrapping current state to be updated by setting a new state to `wrappedValue`.","\/\/\/ Triggers a view update when the state has been changed.","\/\/\/","\/\/\/     let (count, setCount) = useSetState {","\/\/\/         let initialNode = expensiveComputation()","\/\/\/         return initialNode","\/\/\/     }","\/\/\/","\/\/\/     Button(\"Increment\") {","\/\/\/         setCount(count + 1)","\/\/\/     }","\/\/\/","\/\/\/ - Parameter initialNode: A closure creating an initial state. The closure will only be called once, during the initial render.","\/\/\/ - Returns: A `Binding<Node>` wrapping current state.","public func useSetState<Node>(","  _ initialNode: @escaping () -> Node",") -> (Node, (Node) -> Void) {","  useHook(SetStateHook(initialNode: initialNode))","}","","\/\/\/ A hook to use a `Binding<Node>` wrapping current state to be updated by setting a new state to `wrappedValue`.","\/\/\/ Triggers a view update when the state has been changed.","\/\/\/","\/\/\/     let (count, setCount) = useSetState(0)","\/\/\/","\/\/\/     Button(\"Increment\") {","\/\/\/         setCount(count + 1)","\/\/\/     }","\/\/\/","\/\/\/ - Parameter initialNode: An initial state.","\/\/\/ - Returns: A `Binding<Node>` wrapping current state.","public func useSetState<Node>(","_ initialNode: Node",") -> (Node, (Node) -> Void) {","  useSetState {","    initialNode","  }","}","","","private struct SetStateHook<Node>: Hook {","","  typealias State = _HookRef","","  typealias Value = (Node, (Node) -> Void)","","  let updateStrategy: HookUpdateStrategy? = .once","","  let initialNode: () -> Node","","  func makeState() -> State {","    State(initialNode())","  }","","  func value(coordinator: Coordinator) -> Value {","    let node = coordinator.state.node","    let setNode: (Node) -> Void = {","      guard !coordinator.state.isDisposed else {","        return","      }","      coordinator.state.node = $0","      coordinator.updateView()","    }","    return (node, setNode)","  }","","  func updateState(coordinator: Coordinator) {","    guard !coordinator.state.isDisposed else {","      return","    }","  }","","  func dispose(state: State) {","    state.dispose()","  }","}","","private extension SetStateHook {","\/\/ MARK: State","  final class _HookRef {","","    var node: Node","","    var isDisposed = false","","    init(_ initialNode: Node) {","      self.node = initialNode","    }","","    func dispose() {","      isDisposed = true","    }","  }","}",""]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/docchooks\/buildingyourownhooks"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/DocCHooks\/documentation\/DocCHooks\/BuildingYourOwnHooks","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"A SwiftUI implementation of React Hooks. Enhances reusability of stateful logic and gives state and lifecycle to function view."}],"kind":"article","metadata":{"roleHeading":"Article","images":[{"type":"card","identifier":"gettingStarted-card.png"}],"title":"Building Your OwnHooks","role":"article","modules":[{"name":"DocCHooks"}]},"hierarchy":{"paths":[["doc:\/\/DocCHooks\/documentation\/DocCHooks"]]},"references":{"doc://DocCHooks/documentation/DocCHooks/HEnvironment":{"role":"symbol","title":"HEnvironment","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"HEnvironment"}],"abstract":[{"type":"text","text":"A @propertyWrapper for useEnvironment"}],"identifier":"doc:\/\/DocCHooks\/documentation\/DocCHooks\/HEnvironment","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"HEnvironment"}],"url":"\/documentation\/docchooks\/henvironment"},"doc://DocCHooks/documentation/DocCHooks/HRef":{"role":"symbol","title":"HRef","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"HRef"}],"abstract":[{"type":"text","text":"A @propertyWrapper for useRef."}],"identifier":"doc:\/\/DocCHooks\/documentation\/DocCHooks\/HRef","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"HRef"}],"url":"\/documentation\/docchooks\/href"},"doc://DocCHooks/documentation/DocCHooks":{"images":[{"type":"icon","identifier":"slothCreator-icon.png"}],"role":"collection","title":"DocCHooks","abstract":[{"type":"text","text":"A SwiftUI implementation of React Hooks. Enhances reusability of stateful logic and gives state and lifecycle to function view."}],"identifier":"doc:\/\/DocCHooks\/documentation\/DocCHooks","kind":"symbol","type":"topic","url":"\/documentation\/docchooks"},"doc://DocCHooks/documentation/DocCHooks/HContext":{"role":"symbol","title":"HContext","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"HContext"}],"abstract":[{"type":"text","text":"A @propertyWrapper for useContext\/"}],"identifier":"doc:\/\/DocCHooks\/documentation\/DocCHooks\/HContext","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"HContext"}],"url":"\/documentation\/docchooks\/hcontext"},"gettingStarted-card.png":{"alt":null,"type":"image","identifier":"gettingStarted-card.png","variants":[{"url":"\/images\/gettingStarted-card@2x.png","traits":["2x","light"]}]},"doc://DocCHooks/documentation/DocCHooks/HMemo":{"role":"symbol","title":"HMemo","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"HMemo"}],"abstract":[{"type":"text","text":"A @propertyWrapper for useMemo"}],"identifier":"doc:\/\/DocCHooks\/documentation\/DocCHooks\/HMemo","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"HMemo"}],"url":"\/documentation\/docchooks\/hmemo"},"doc://DocCHooks/documentation/DocCHooks/HState":{"role":"symbol","title":"HState","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"HState"}],"abstract":[{"type":"text","text":"A @propertyWrapper for useState"}],"identifier":"doc:\/\/DocCHooks\/documentation\/DocCHooks\/HState","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"HState"}],"url":"\/documentation\/docchooks\/hstate"},"slothCreator-icon.png":{"alt":"A technology icon representing the SlothCreator framework.","type":"image","identifier":"slothCreator-icon.png","variants":[{"url":"\/images\/slothCreator-icon@2x.png","traits":["2x","light"]}]}}}